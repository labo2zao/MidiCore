#include "Services/usb_midi/usb_midi.h"
#include "Services/router/router.h"
#include "Config/module_config.h"
#include <string.h>

/* Check if USB Device files are available before including them */


#if MODULE_ENABLE_USB_MIDI

#include "usb_device.h"
#include "USB_DEVICE/Class/MIDI/Inc/usbd_midi.h"  /* Custom MIDI class - protected from CubeMX regen */

/* External USB Device handle (generated by CubeMX) */
extern USBD_HandleTypeDef hUsbDeviceFS;

/* Optional debug hook for test modules - weak symbol can be overridden */
__attribute__((weak)) void usb_midi_rx_debug_hook(const uint8_t packet4[4]) {
  /* Default: do nothing. Test modules can override this to log packets */
  (void)packet4;
}

/* SysEx buffer management - one buffer per cable (4 cables total) */
#define USB_MIDI_SYSEX_BUFFER_SIZE 256
typedef struct {
  uint8_t buffer[USB_MIDI_SYSEX_BUFFER_SIZE];
  uint16_t pos;
  uint8_t active;
  uint8_t padding; // Align to 4-byte boundary for faster access
} sysex_buffer_t;

static sysex_buffer_t sysex_buffers[4] __attribute__((aligned(4))); // 4 cables, 4-byte aligned

/* Message length lookup table for faster processing (indexed by CIN 0x0-0xF) */
static const uint8_t cin_to_length[16] = {
  0, // 0x0: Reserved
  0, // 0x1: Reserved
  2, // 0x2: Two-byte System Common
  3, // 0x3: Three-byte System Common
  3, // 0x4: SysEx start/continue (3 bytes)
  1, // 0x5: SysEx end 1 byte / Single-byte System Common
  2, // 0x6: SysEx end 2 bytes
  3, // 0x7: SysEx end 3 bytes
  3, // 0x8: Note Off
  3, // 0x9: Note On
  3, // 0xA: Poly Aftertouch
  3, // 0xB: Control Change
  2, // 0xC: Program Change
  2, // 0xD: Channel Pressure
  3, // 0xE: Pitch Bend
  1  // 0xF: Single byte (System Real-Time)
};

/* MIDI Interface Callbacks */
static void USBD_MIDI_Init_Callback(void);
static void USBD_MIDI_DeInit_Callback(void);
static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet);

static USBD_MIDI_ItfTypeDef midi_fops = {
  USBD_MIDI_Init_Callback,
  USBD_MIDI_DeInit_Callback,
  USBD_MIDI_DataOut_Callback
};

void usb_midi_init(void) {
  /* Initialize SysEx buffers */
  memset(sysex_buffers, 0, sizeof(sysex_buffers));
  
  /* Register interface callbacks with USB Device MIDI class */
  USBD_MIDI_RegisterInterface(&hUsbDeviceFS, &midi_fops);
}

void usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  /* Extract cable number from CIN (upper 4 bits) */
  uint8_t cable = (cin >> 4) & 0x0F;
  
  /* Build MIDI message (without header) */
  uint8_t data[3] = {b0, b1, b2};
  uint16_t length = 3;
  
  /* Adjust length based on message type (like MIOS32) */
  uint8_t status = b0 & 0xF0;
  if (status == 0xC0 || status == 0xD0) {
    length = 2; /* Program Change, Channel Pressure - 2 bytes */
  }
  
  /* Send via USB Device MIDI (4 ports supported) */
  USBD_MIDI_SendData(&hUsbDeviceFS, cable, data, length);
}

void usb_midi_rx_packet(const uint8_t packet4[4]) {
  /* Extract cable number (upper 4 bits) and CIN (lower 4 bits) - single operation */
  const uint8_t header = packet4[0];
  const uint8_t cable = header >> 4;
  const uint8_t cin = header & 0x0F;
  
  /* Fast cable validation and early return */
  if (cable > 3) return;
  
  /* Call debug hook if defined (after validation to reduce overhead) */
  usb_midi_rx_debug_hook(packet4);
  
  /* Map cable 0-3 to USB_PORT0-3 nodes (like MIOS32's USB0-USB3) */
  const uint8_t node = ROUTER_NODE_USB_PORT0 + cable;
  
  /* Handle SysEx messages (CIN 0x4-0x7) - optimized path */
  if (cin >= 0x04 && cin <= 0x07) {
    sysex_buffer_t* const buf = &sysex_buffers[cable];
    const uint8_t num_bytes = cin_to_length[cin];
    
    /* CIN 0x4: SysEx start or continue (3 bytes) */
    if (cin == 0x04) {
      /* If first byte is F0, start new SysEx */
      if (packet4[1] == 0xF0) {
        buf->pos = 0;
        buf->active = 1;
      }
      
      /* Fast buffer copy if active and space available (unrolled for 3 bytes) */
      if (buf->active) {
        if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->buffer[buf->pos + 2] = packet4[3];
          buf->pos += 3;
        } else {
          /* Buffer overflow - discard this SysEx and reset */
          buf->pos = 0;
          buf->active = 0;
        }
      }
      return; /* Don't send yet - wait for end packet */
    }
    
    /* CIN 0x5: SysEx end with 1 byte (or single-byte System Common) */
    else if (cin == 0x05) {
      if (buf->active) {
        if (buf->pos + 1 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          buf->buffer[buf->pos++] = packet4[1];
          
          /* Fast SysEx validation (check start and end markers) */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Only route if not in test mode with APP_TEST_USB_MIDI */
            #ifndef APP_TEST_USB_MIDI
            /* Prepare message inline to avoid extra copies */
            router_msg_t msg;
            msg.type = ROUTER_MSG_SYSEX;
            msg.data = buf->buffer;
            msg.len = buf->pos;
            msg.b0 = 0xF0;
            msg.b1 = 0;
            msg.b2 = 0;
            router_process(node, &msg);
            #endif
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      return;
    }
    
    /* CIN 0x6: SysEx end with 2 bytes (or two-byte System Common) */
    else if (cin == 0x06) {
      if (buf->active) {
        if (buf->pos + 2 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 2 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->pos += 2;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            #ifndef APP_TEST_USB_MIDI
            router_msg_t msg;
            msg.type = ROUTER_MSG_SYSEX;
            msg.data = buf->buffer;
            msg.len = buf->pos;
            msg.b0 = 0xF0;
            msg.b1 = 0;
            msg.b2 = 0;
            router_process(node, &msg);
            #endif
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      return;
    }
    
    /* CIN 0x7: SysEx end with 3 bytes */
    else if (cin == 0x07) {
      if (buf->active) {
        if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 3 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->buffer[buf->pos + 2] = packet4[3];
          buf->pos += 3;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            #ifndef APP_TEST_USB_MIDI
            router_msg_t msg;
            msg.type = ROUTER_MSG_SYSEX;
            msg.data = buf->buffer;
            msg.len = buf->pos;
            msg.b0 = 0xF0;
            msg.b1 = 0;
            msg.b2 = 0;
            router_process(node, &msg);
            #endif
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      return;
    }
  }
  
  /* Handle regular MIDI messages (non-SysEx) - optimized with lookup table */
  const uint8_t msg_len = cin_to_length[cin];
  
  /* Fast rejection of invalid CINs */
  if (msg_len == 0) return;
  
  /* Prepare message inline - optimized for common case (3-byte messages) */
  router_msg_t msg;
  msg.data = NULL;
  msg.len = 0;
  msg.b0 = packet4[1];
  msg.b1 = packet4[2];
  msg.b2 = packet4[3];
  
  /* Set message type based on length (fast path) */
  if (msg_len == 3) {
    msg.type = ROUTER_MSG_3B;
  } else if (msg_len == 2) {
    msg.type = ROUTER_MSG_2B;
    msg.b2 = 0;
  } else { /* msg_len == 1 */
    msg.type = ROUTER_MSG_1B;
    msg.b1 = 0;
    msg.b2 = 0;
  }
  
  /* Send to router */
  router_process(node, &msg);
}

/* Callbacks */
static void USBD_MIDI_Init_Callback(void) {
  /* USB MIDI initialized - all 4 ports ready */
}

static void USBD_MIDI_DeInit_Callback(void) {
  /* USB MIDI de-initialized */
}

static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet) {
  /* Forward packet to application layer (4-byte USB MIDI packet) */
  usb_midi_rx_packet((uint8_t*)packet);
}

#else /* !MODULE_ENABLE_USB_MIDI || !USB_DEVICE_AVAILABLE */

/* Stub implementations when USB Device MIDI is not enabled or USB_DEVICE files don't exist */
void usb_midi_init(void) {
  /* USB Device MIDI not available - either disabled or CubeMX files not generated yet */
}

void usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  (void)cin; (void)b0; (void)b1; (void)b2;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
}

void usb_midi_rx_packet(const uint8_t packet4[4]) {
  (void)packet4;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
}

#endif /* MODULE_ENABLE_USB_MIDI && USB_DEVICE_AVAILABLE */
