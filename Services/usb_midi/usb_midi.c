#include "Services/usb_midi/usb_midi.h"
#include "Services/router/router.h"
#include "Services/mios32_query/mios32_query.h"
#include "Config/module_config.h"
#include <string.h>

/* Check if USB Device files are available before including them */


#if MODULE_ENABLE_USB_MIDI

#include "usb_device.h"
#include "USB_DEVICE/Class/MIDI/Inc/usbd_midi.h"  /* Custom MIDI class - protected from CubeMX regen */

/* External USB Device handle (generated by CubeMX) */
extern USBD_HandleTypeDef hUsbDeviceFS;

/* Optional debug hook for test modules - weak symbol can be overridden */
__attribute__((weak)) void usb_midi_rx_debug_hook(const uint8_t packet4[4]) {
  /* Default: do nothing. Test modules can override this to log packets */
  (void)packet4;
}

/* SysEx buffer management - one buffer per cable (4 cables total) */
#define USB_MIDI_SYSEX_BUFFER_SIZE 256
typedef struct {
  uint8_t buffer[USB_MIDI_SYSEX_BUFFER_SIZE];
  uint16_t pos;
  uint8_t active;
  uint8_t padding; // Align to 4-byte boundary for faster access
} sysex_buffer_t;

static sysex_buffer_t sysex_buffers[4] __attribute__((aligned(4))); // 4 cables, 4-byte aligned

/* TX Queue for packet buffering - CRITICAL FIX for packet dropping issue
 * 
 * Problem: usb_midi_send_sysex() calls usb_midi_send_packet() multiple times in a tight loop
 * for multi-packet messages. USB Full Speed can only transmit 1 packet per ~1ms, but we were
 * trying to send packets in microseconds, causing all but the first packet to be dropped.
 * 
 * Solution: Queue packets and send them as TX completes (flow control).
 */
#define USB_MIDI_TX_QUEUE_SIZE 32  // Power of 2 for efficient modulo with & mask
typedef struct {
  uint8_t packet[4];  // CIN + 3 data bytes
} tx_packet_t;

static tx_packet_t tx_queue[USB_MIDI_TX_QUEUE_SIZE] __attribute__((aligned(4)));
static volatile uint8_t tx_queue_head = 0;  // Next position to write
static volatile uint8_t tx_queue_tail = 0;  // Next position to read
static volatile uint8_t tx_in_progress = 0; // Flag: transmission active

/* TX Queue helper functions */
static inline uint8_t tx_queue_is_full(void) {
  return ((tx_queue_head + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1)) == tx_queue_tail;
}

static inline uint8_t tx_queue_is_empty(void) {
  return tx_queue_head == tx_queue_tail;
}

static void tx_queue_send_next(void);

/* RX Queue for deferred processing - CRITICAL FIX for interrupt context issues
 * 
 * Problem: RX interrupt was processing packets immediately, including sending TX responses
 * in the same interrupt context. This violates USB protocol and causes race conditions.
 * 
 * Solution: Queue RX packets in interrupt, process them in task context.
 */
#define USB_MIDI_RX_QUEUE_SIZE 16  // Power of 2
typedef struct {
  uint8_t packet[4];  // Header (cable+CIN) + 3 data bytes
} rx_packet_t;

static rx_packet_t rx_queue[USB_MIDI_RX_QUEUE_SIZE] __attribute__((aligned(4)));
static volatile uint8_t rx_queue_head = 0;  // Next position to write (ISR)
static volatile uint8_t rx_queue_tail = 0;  // Next position to read (task)

/* RX Queue helper functions */
static inline uint8_t rx_queue_is_full(void) {
  return ((rx_queue_head + 1) & (USB_MIDI_RX_QUEUE_SIZE - 1)) == rx_queue_tail;
}

static inline uint8_t rx_queue_is_empty(void) {
  return rx_queue_head == rx_queue_tail;
}

/* Message length lookup table for faster processing (indexed by CIN 0x0-0xF) */
static const uint8_t cin_to_length[16] = {
  0, // 0x0: Reserved
  0, // 0x1: Reserved
  2, // 0x2: Two-byte System Common
  3, // 0x3: Three-byte System Common
  3, // 0x4: SysEx start/continue (3 bytes)
  1, // 0x5: SysEx end 1 byte / Single-byte System Common
  2, // 0x6: SysEx end 2 bytes
  3, // 0x7: SysEx end 3 bytes
  3, // 0x8: Note Off
  3, // 0x9: Note On
  3, // 0xA: Poly Aftertouch
  3, // 0xB: Control Change
  2, // 0xC: Program Change
  2, // 0xD: Channel Pressure
  3, // 0xE: Pitch Bend
  1  // 0xF: Single byte (System Real-Time)
};

/* MIDI Interface Callbacks */
static void USBD_MIDI_Init_Callback(void);
static void USBD_MIDI_DeInit_Callback(void);
static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet);

static USBD_MIDI_ItfTypeDef midi_fops = {
  USBD_MIDI_Init_Callback,
  USBD_MIDI_DeInit_Callback,
  USBD_MIDI_DataOut_Callback
};

void usb_midi_init(void) {
  /* Initialize SysEx buffers */
  memset(sysex_buffers, 0, sizeof(sysex_buffers));
  
  /* Initialize TX queue */
  tx_queue_head = 0;
  tx_queue_tail = 0;
  tx_in_progress = 0;
  
  /* Register interface callbacks with USB Device MIDI class */
  USBD_MIDI_RegisterInterface(&hUsbDeviceFS, &midi_fops);
}

/* Send next packet from TX queue (called from tx_queue_send_next and DataIn callback) */
static void tx_queue_send_next(void) {
  USBD_MIDI_HandleTypeDef *hmidi = (USBD_MIDI_HandleTypeDef *)hUsbDeviceFS.pClassData;
  
  /* Check if interface is ready */
  if (hmidi == NULL || !hmidi->is_ready) {
    tx_in_progress = 0;
    return;
  }
  
  /* Check if queue is empty */
  if (tx_queue_is_empty()) {
    tx_in_progress = 0;
    return;
  }
  
  /* Check if endpoint is busy */
  if (hUsbDeviceFS.ep_in[MIDI_IN_EP & 0x0F].status == USBD_BUSY) {
    /* Endpoint busy - keep tx_in_progress flag set, will retry on next TX complete */
    return;
  }
  
  /* Get next packet from queue */
  tx_packet_t *pkt = &tx_queue[tx_queue_tail];
  tx_queue_tail = (tx_queue_tail + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1);
  
  /* Mark transmission in progress */
  tx_in_progress = 1;
  
  /* Transmit packet */
  USBD_LL_Transmit(&hUsbDeviceFS, MIDI_IN_EP, pkt->packet, 4);
}

void usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  /* CRITICAL FIX: Queue packets instead of sending directly
   * 
   * Problem: Calling USBD_LL_Transmit() in a tight loop causes packet drops because
   * USB Full Speed can only handle ~1 packet per ms, but we were sending packets in Î¼s.
   * 
   * Solution: Buffer packets in queue, send as TX completes (flow control).
   * This ensures reliable multi-packet message delivery (SysEx, etc.)
   */
  
  /* Check if queue is full */
  if (tx_queue_is_full()) {
    /* Queue full - drop packet (should rarely happen with 32-deep queue) */
    return;
  }
  
  /* Add packet to queue */
  tx_packet_t *pkt = &tx_queue[tx_queue_head];
  pkt->packet[0] = cin;  /* Cable number (upper 4 bits) + CIN (lower 4 bits) */
  pkt->packet[1] = b0;
  pkt->packet[2] = b1;
  pkt->packet[3] = b2;
  tx_queue_head = (tx_queue_head + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1);
  
  /* If no transmission in progress, start sending */
  if (!tx_in_progress) {
    tx_queue_send_next();
  }
}

void usb_midi_rx_packet(const uint8_t packet4[4]) {
  /* Extract cable number (upper 4 bits) and CIN (lower 4 bits) - single operation */
  const uint8_t header = packet4[0];
  const uint8_t cable = header >> 4;
  const uint8_t cin = header & 0x0F;
  
  /* Fast cable validation and early return */
  if (cable > 3) return;
  
  /* Call debug hook if defined (after validation to reduce overhead) */
  usb_midi_rx_debug_hook(packet4);
  
  /* Map cable 0-3 to USB_PORT0-3 nodes (like MIOS32's USB0-USB3) */
  const uint8_t node = ROUTER_NODE_USB_PORT0 + cable;
  
  /* Handle SysEx messages (CIN 0x4-0x7) - optimized path */
  if (cin >= 0x04 && cin <= 0x07) {
    sysex_buffer_t* const buf = &sysex_buffers[cable];
    const uint8_t num_bytes = cin_to_length[cin];
    
    /* CIN 0x4: SysEx start or continue (3 bytes) */
    if (cin == 0x04) {
      /* If first byte is F0, start new SysEx */
      if (packet4[1] == 0xF0) {
        buf->pos = 0;
        buf->active = 1;
      }
      
      /* Fast buffer copy if active and space available (unrolled for 3 bytes) */
      if (buf->active) {
        if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->buffer[buf->pos + 2] = packet4[3];
          buf->pos += 3;
        } else {
          /* Buffer overflow - discard this SysEx and reset */
          buf->pos = 0;
          buf->active = 0;
        }
      }
      return; /* Don't send yet - wait for end packet */
    }
    
    /* CIN 0x5: SysEx end with 1 byte (or single-byte System Common) */
    else if (cin == 0x05) {
      if (buf->active) {
        if (buf->pos + 1 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          buf->buffer[buf->pos++] = packet4[1];
          
          /* Fast SysEx validation (check start and end markers) */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MIOS32 query message - respond to it */
            if (mios32_query_is_query_message(buf->buffer, buf->pos)) {
              /* Process MIOS32 query and send response (MIOS Studio expects this) */
              mios32_query_process(buf->buffer, buf->pos, cable);
              /* Don't route query messages - they're handled above */
            } else {
              /* Only route if not in test mode with APP_TEST_USB_MIDI */
              #ifndef APP_TEST_USB_MIDI
              /* Prepare message inline to avoid extra copies */
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      return;
    }
    
    /* CIN 0x6: SysEx end with 2 bytes (or two-byte System Common) */
    else if (cin == 0x06) {
      if (buf->active) {
        if (buf->pos + 2 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 2 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->pos += 2;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MIOS32 query message - respond to it */
            if (mios32_query_is_query_message(buf->buffer, buf->pos)) {
              /* Process MIOS32 query and send response (MIOS Studio expects this) */
              mios32_query_process(buf->buffer, buf->pos, cable);
              /* Don't route query messages - they're handled above */
            } else {
              #ifndef APP_TEST_USB_MIDI
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      return;
    }
    
    /* CIN 0x7: SysEx end with 3 bytes */
    else if (cin == 0x07) {
      if (buf->active) {
        if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 3 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->buffer[buf->pos + 2] = packet4[3];
          buf->pos += 3;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MIOS32 query message - respond to it */
            if (mios32_query_is_query_message(buf->buffer, buf->pos)) {
              /* Process MIOS32 query and send response (MIOS Studio expects this) */
              mios32_query_process(buf->buffer, buf->pos, cable);
              /* Don't route query messages - they're handled above */
            } else {
              #ifndef APP_TEST_USB_MIDI
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      return;
    }
  }
  
  /* Handle regular MIDI messages (non-SysEx) - optimized with lookup table */
  const uint8_t msg_len = cin_to_length[cin];
  
  /* Fast rejection of invalid CINs */
  if (msg_len == 0) return;
  
  /* Prepare message inline - optimized for common case (3-byte messages) */
  router_msg_t msg;
  msg.data = NULL;
  msg.len = 0;
  msg.b0 = packet4[1];
  msg.b1 = packet4[2];
  msg.b2 = packet4[3];
  
  /* Set message type based on length (fast path) */
  if (msg_len == 3) {
    msg.type = ROUTER_MSG_3B;
  } else if (msg_len == 2) {
    msg.type = ROUTER_MSG_2B;
    msg.b2 = 0;
  } else { /* msg_len == 1 */
    msg.type = ROUTER_MSG_1B;
    msg.b1 = 0;
    msg.b2 = 0;
  }
  
  /* Send to router */
  router_process(node, &msg);
}

/* Callbacks */
/* TX Complete callback - called from USB MIDI class when packet transmission completes */
void usb_midi_tx_complete(void) {
  /* Send next packet from queue */
  tx_queue_send_next();
}

static void USBD_MIDI_Init_Callback(void) {
  /* USB MIDI initialized - all 4 ports ready */
}

static void USBD_MIDI_DeInit_Callback(void) {
  /* USB MIDI de-initialized */
}

static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet) {
  /* Forward packet to application layer (4-byte USB MIDI packet) */
  usb_midi_rx_packet((uint8_t*)packet);
}

#else /* !MODULE_ENABLE_USB_MIDI || !USB_DEVICE_AVAILABLE */

/* Stub implementations when USB Device MIDI is not enabled or USB_DEVICE files don't exist */
void usb_midi_init(void) {
  /* USB Device MIDI not available - either disabled or CubeMX files not generated yet */
}

void usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  (void)cin; (void)b0; (void)b1; (void)b2;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
}

void usb_midi_rx_packet(const uint8_t packet4[4]) {
  (void)packet4;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
}

#endif /* MODULE_ENABLE_USB_MIDI && USB_DEVICE_AVAILABLE */
