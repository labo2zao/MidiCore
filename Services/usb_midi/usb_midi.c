#include "Services/usb_midi/usb_midi.h"
#include "Services/router/router.h"
#include "Services/midicore_query/midicore_query.h"
#include "Config/module_config.h"
#include <string.h>
#include <stdio.h>

/* Check if USB Device files are available before including them */


#if MODULE_ENABLE_USB_MIDI

#include "usb_device.h"
#include "USB_DEVICE/Class/MIDI/Inc/usbd_midi.h"  /* Custom MIDI class - protected from CubeMX regen */
#include "USB_DEVICE/App/usbd_composite.h"

/* External USB Device handle (generated by CubeMX) */
extern USBD_HandleTypeDef hUsbDeviceFS;

/*===========================================================================*/
/* USB MIDI TX Diagnostic Functions - PRODUCTION (for MIOS Studio terminal)  */
/*===========================================================================*/

/**
 * @brief USB MIDI TX error trace - REAL production function
 * 
 * Logs TX errors for MIOS Studio terminal diagnostics.
 * Only logs real errors, not normal conditions like "queue empty".
 * 
 * @param code Error code:
 *   - 0x01: Class data NULL or not ready
 *   - 0x02: Queue empty (normal, not logged)
 *   - 0x03: Endpoint busy
 *   - 0xFF: Queue full (packet dropped)
 */
void usb_midi_tx_trace(uint8_t code)
{
  #if MODULE_DEBUG_MIDICORE_QUERIES
  const char* msg;
  
  switch(code) {
    case 0x01: msg = "[TX-ERR] USB MIDI not ready\r\n"; break;
    case 0x02: return; /* Queue empty is normal */
    case 0x03: msg = "[TX-WARN] Endpoint busy\r\n"; break;
    case 0xFF: msg = "[TX-ERR] Queue FULL - packet dropped!\r\n"; break;
    default: return;
  }
  
  /* Send to debug output (UART or CDC based on config) */
  extern void dbg_print(const char *str);
  dbg_print(msg);
  #else
  (void)code;
  #endif
}

/**
 * @brief USB MIDI packet queued trace - REAL production function
 * 
 * Optional detailed tracing for packet queue debugging.
 * Disabled by default to reduce log noise.
 * 
 * @param cin Cable Index Number
 * @param b0 First MIDI byte (status)
 */
void usb_midi_tx_packet_trace(uint8_t cin, uint8_t b0)
{
  /* Disabled by default - enable for detailed TX debugging */
  #if MODULE_DEBUG_USB_MIDI_TX_PACKETS
  extern void dbg_printf(const char *fmt, ...);
  dbg_printf("[TX-PKT] CIN:%02X Status:%02X\r\n", cin, b0);
  #else
  (void)cin;
  (void)b0;
  #endif
}

/*===========================================================================*/
/* USB MIDI RX Hook - REAL implementation (no stubs)                         */
/*===========================================================================*/

/* Include router header when enabled */
#if MODULE_ENABLE_ROUTER
#include "Services/router/router.h"
#endif

/**
 * @brief USB MIDI RX hook - routes incoming MIDI to appropriate handlers
 * 
 * This is the REAL implementation - no stubs.
 * Called for every USB MIDI packet received.
 * Routes to: router, MIDI learn, activity LED, etc.
 */
void usb_midi_rx_debug_hook(const uint8_t packet4[4])
{
  uint8_t cin = packet4[0] & 0x0F;
  uint8_t cable = (packet4[0] >> 4) & 0x0F;
  
  /* Update activity indicator (for LED feedback) */
  static uint32_t last_rx_time = 0;
  extern uint32_t HAL_GetTick(void);
  last_rx_time = HAL_GetTick();
  (void)last_rx_time; /* Will be used for activity LED */
  
  /* Route to MIDI router for processing */
  #if MODULE_ENABLE_ROUTER
  {
    /* Convert USB MIDI packet to router message */
    router_msg_t msg;
    uint8_t status = packet4[1];
    
    /* Determine message type from CIN */
    switch (cin) {
      case 0x08: /* Note Off */
      case 0x09: /* Note On */
      case 0x0A: /* Poly Aftertouch */
      case 0x0B: /* Control Change */
      case 0x0E: /* Pitch Bend */
        msg.type = ROUTER_MSG_3B;
        msg.b0 = packet4[1];
        msg.b1 = packet4[2];
        msg.b2 = packet4[3];
        msg.data = NULL;
        msg.len = 0;
        /* USB input is node 0 (USB_MIDI port) */
        router_process(0, &msg);
        break;
        
      case 0x0C: /* Program Change */
      case 0x0D: /* Channel Aftertouch */
        msg.type = ROUTER_MSG_2B;
        msg.b0 = packet4[1];
        msg.b1 = packet4[2];
        msg.b2 = 0;
        msg.data = NULL;
        msg.len = 0;
        router_process(0, &msg);
        break;
        
      /* SysEx handled separately via sysex buffer */
      default:
        break;
    }
    (void)status; /* May be used later */
  }
  #endif
  
  /* Debug logging only in debug/test mode */
  #if MODULE_DEBUG_MIDICORE_QUERIES || defined(MODULE_TEST_USB_DEVICE_MIDI)
  /* Skip SysEx packets (CIN 0x4-0x7) to prevent stack overflow */
  if (cin >= 0x04 && cin <= 0x07) {
    return;
  }
  dbg_printf("[USB-RX] Cable:%u CIN:0x%X Data:[%02X %02X %02X %02X]\r\n",
             cable, cin, packet4[0], packet4[1], packet4[2], packet4[3]);
  #else
  (void)cin;
  (void)cable;
  #endif
}

/* SysEx buffer management - one buffer per cable (4 cables total) */
#define USB_MIDI_SYSEX_BUFFER_SIZE 256
typedef struct {
  uint8_t buffer[USB_MIDI_SYSEX_BUFFER_SIZE];
  uint16_t pos;
  uint8_t active;
  uint8_t padding; // Align to 4-byte boundary for faster access
} sysex_buffer_t;

static sysex_buffer_t sysex_buffers[4] __attribute__((aligned(4))); // 4 cables, 4-byte aligned

/* TX Queue for packet buffering - CRITICAL FIX for packet dropping issue
 * 
 * Problem: usb_midi_send_sysex() calls usb_midi_send_packet() multiple times in a tight loop
 * for multi-packet messages. USB Full Speed can only transmit 1 packet per ~1ms, but we were
 * trying to send packets in microseconds, causing all but the first packet to be dropped.
 * 
 * Solution: Queue packets and send them as TX completes (flow control).
 * 
 * QUEUE SIZE: Increased from 32 to 64 packets to handle debug message bursts.
 * - Each debug SysEx message = ~8-10 packets
 * - 64 packets = ~6-8 complete debug messages can be queued
 * - Prevents drops during high-volume debug output (e.g., MIOS Studio terminal)
 */
#define USB_MIDI_TX_QUEUE_SIZE 64  // Power of 2 for efficient modulo with & mask
typedef struct {
  uint8_t packet[4];  // CIN + 3 data bytes
} tx_packet_t;

static tx_packet_t tx_queue[USB_MIDI_TX_QUEUE_SIZE] __attribute__((aligned(4)));
static volatile uint8_t tx_queue_head = 0;  // Next position to write
static volatile uint8_t tx_queue_tail = 0;  // Next position to read
static volatile uint8_t tx_in_progress = 0; // Flag: transmission active
static volatile uint32_t tx_queue_drops = 0; // Count of dropped packets due to queue full

/* TX Queue helper functions */
static inline uint8_t tx_queue_is_full(void) {
  return ((tx_queue_head + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1)) == tx_queue_tail;
}

static inline uint8_t tx_queue_is_empty(void) {
  return tx_queue_head == tx_queue_tail;
}

static inline uint8_t tx_queue_count(void) {
  if (tx_queue_head >= tx_queue_tail) {
    return tx_queue_head - tx_queue_tail;
  } else {
    return USB_MIDI_TX_QUEUE_SIZE - tx_queue_tail + tx_queue_head;
  }
}

static void tx_queue_send_next(void);

/* RX Queue for deferred processing - CRITICAL FIX for interrupt context issues
 * 
 * Problem: RX interrupt was processing packets immediately, including sending TX responses
 * in the same interrupt context. This violates USB protocol and causes race conditions.
 * 
 * Solution: Queue RX packets in interrupt, process them in task context.
 */
#define USB_MIDI_RX_QUEUE_SIZE 16  // Power of 2
typedef struct {
  uint8_t packet[4];  // Header (cable+CIN) + 3 data bytes
} rx_packet_t;

static rx_packet_t rx_queue[USB_MIDI_RX_QUEUE_SIZE] __attribute__((aligned(4)));
static volatile uint8_t rx_queue_head = 0;  // Next position to write (ISR)
static volatile uint8_t rx_queue_tail = 0;  // Next position to read (task)

/* RX Queue helper functions */
static inline uint8_t rx_queue_is_full(void) {
  return ((rx_queue_head + 1) & (USB_MIDI_RX_QUEUE_SIZE - 1)) == rx_queue_tail;
}

static inline uint8_t rx_queue_is_empty(void) {
  return rx_queue_head == rx_queue_tail;
}

/* Message length lookup table for faster processing (indexed by CIN 0x0-0xF) */
static const uint8_t cin_to_length[16] = {
  0, // 0x0: Reserved
  0, // 0x1: Reserved
  2, // 0x2: Two-byte System Common
  3, // 0x3: Three-byte System Common
  3, // 0x4: SysEx start/continue (3 bytes)
  1, // 0x5: SysEx end 1 byte / Single-byte System Common
  2, // 0x6: SysEx end 2 bytes
  3, // 0x7: SysEx end 3 bytes
  3, // 0x8: Note Off
  3, // 0x9: Note On
  3, // 0xA: Poly Aftertouch
  3, // 0xB: Control Change
  2, // 0xC: Program Change
  2, // 0xD: Channel Pressure
  3, // 0xE: Pitch Bend
  1  // 0xF: Single byte (System Real-Time)
};

/* MIDI Interface Callbacks */
static void USBD_MIDI_Init_Callback(void);
static void USBD_MIDI_DeInit_Callback(void);
static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet);

static USBD_MIDI_ItfTypeDef midi_fops = {
  USBD_MIDI_Init_Callback,
  USBD_MIDI_DeInit_Callback,
  USBD_MIDI_DataOut_Callback
};

static USBD_MIDI_HandleTypeDef *usb_midi_get_class_data(void) {
#if MODULE_ENABLE_USB_CDC
  void *class_data = USBD_COMPOSITE_GetClassData(&USBD_MIDI);
  if (class_data != NULL) {
    return (USBD_MIDI_HandleTypeDef *)class_data;
  }
#endif
  return (USBD_MIDI_HandleTypeDef *)hUsbDeviceFS.pClassData;
}

void usb_midi_init(void) {
  /* Initialize SysEx buffers */
  memset(sysex_buffers, 0, sizeof(sysex_buffers));
  
  /* Initialize TX queue */
  tx_queue_head = 0;
  tx_queue_tail = 0;
  tx_in_progress = 0;
  
  /* Register interface callbacks with USB Device MIDI class */
  USBD_MIDI_RegisterInterface(&hUsbDeviceFS, &midi_fops);
}

/* Send next packet from TX queue (called from tx_queue_send_next and DataIn callback) */
static void tx_queue_send_next(void) {
  USBD_MIDI_HandleTypeDef *hmidi = usb_midi_get_class_data();
  
  /* Check if interface is ready */
  if (hmidi == NULL || !hmidi->is_ready) {
    usb_midi_tx_trace(0x01);  /* Not ready */
    tx_in_progress = 0;
    return;
  }
  
  /* Check if queue is empty */
  if (tx_queue_is_empty()) {
    usb_midi_tx_trace(0x02);  /* Queue empty (normal) */
    tx_in_progress = 0;
    return;
  }
  
  /* Check if endpoint is busy */
  if (hUsbDeviceFS.ep_in[MIDI_IN_EP & 0x0F].status == USBD_BUSY) {
    usb_midi_tx_trace(0x03);  /* Endpoint busy */
    /* Endpoint busy - keep tx_in_progress flag set, will retry on next TX complete */
    return;
  }
  
  /* Get next packet from queue */
  tx_packet_t *pkt = &tx_queue[tx_queue_tail];
  tx_queue_tail = (tx_queue_tail + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1);
  
  /* Mark transmission in progress */
  tx_in_progress = 1;
  
  /* Transmit packet */
  USBD_LL_Transmit(&hUsbDeviceFS, MIDI_IN_EP, pkt->packet, 4);
}

bool usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  /* CRITICAL FIX: Queue packets instead of sending directly
   * 
   * Problem: Calling USBD_LL_Transmit() in a tight loop causes packet drops because
   * USB Full Speed can only handle ~1 packet per ms, but we were sending packets in Î¼s.
   * 
   * Solution: Buffer packets in queue, send as TX completes (flow control).
   * This ensures reliable multi-packet message delivery (SysEx, etc.)
   * 
   * Returns true if packet queued, false if queue full (caller can implement backpressure)
   */
  
  /* Trace packet for debugging (disabled by default) */
  usb_midi_tx_packet_trace(cin, b0);
  
  /* Check if queue is full */
  if (tx_queue_is_full()) {
    usb_midi_tx_trace(0xFF);  /* Queue full! */
    /* Queue full - return false so caller knows packet was dropped */
    tx_queue_drops++;  // Track drops
    return false;
  }
  
  /* Add packet to queue */
  tx_packet_t *pkt = &tx_queue[tx_queue_head];
  pkt->packet[0] = cin;  /* Cable number (upper 4 bits) + CIN (lower 4 bits) */
  pkt->packet[1] = b0;
  pkt->packet[2] = b1;
  pkt->packet[3] = b2;
  tx_queue_head = (tx_queue_head + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1);
  
  /* If no transmission in progress, start sending */
  if (!tx_in_progress) {
    tx_queue_send_next();
  }
  
  return true;  /* Packet queued successfully */
}

/* CRITICAL FIX: Queue RX packet for deferred processing
 * 
 * This function is called from USB interrupt context. We MUST NOT do heavy processing
 * here (router, MidiCore queries, TX operations). Instead, queue the packet and return
 * immediately. Processing happens in task context via usb_midi_process_rx_queue().
 * 
 * This fixes the freeze issue where MidiCore query responses were being sent from
 * RX interrupt, violating USB protocol and causing race conditions.
 */
void usb_midi_rx_packet(const uint8_t packet4[4]) {
  /* INTERRUPT CONTEXT - Keep this FAST! */
  
  /* Check if queue is full (should be rare with 16-deep queue) */
  if (rx_queue_is_full()) {
    /* Drop packet - queue overflow */
    return;
  }
  
  /* Copy packet to queue (4-byte copy is atomic on 32-bit CPU) */
  rx_packet_t *pkt = &rx_queue[rx_queue_head];
  pkt->packet[0] = packet4[0];
  pkt->packet[1] = packet4[1];
  pkt->packet[2] = packet4[2];
  pkt->packet[3] = packet4[3];
  
  /* Advance write pointer */
  rx_queue_head = (rx_queue_head + 1) & (USB_MIDI_RX_QUEUE_SIZE - 1);
  
  /* That's it! Processing happens in task context */
}

/* Process RX queue - MUST be called from task context (NOT interrupt!)
 * 
 * Call this from main loop or dedicated USB MIDI task. It processes all queued
 * RX packets, assembles SysEx messages, handles MidiCore queries, and routes to
 * the MIDI router.
 * 
 * This function contains the actual processing logic that was previously in
 * usb_midi_rx_packet() but is now properly deferred to task context.
 */
void usb_midi_process_rx_queue(void) {
  /* TASK CONTEXT - Safe to do heavy processing and TX operations */
  
  /* Process all queued packets */
  while (!rx_queue_is_empty()) {
    /* Get next packet from queue */
    rx_packet_t *pkt = &rx_queue[rx_queue_tail];
    const uint8_t *packet4 = pkt->packet;
    
    /* Advance read pointer before processing (in case processing triggers more RX) */
    rx_queue_tail = (rx_queue_tail + 1) & (USB_MIDI_RX_QUEUE_SIZE - 1);
    
    /* NOW do the actual processing (same logic as before, but in task context) */
    
    /* Extract cable number (upper 4 bits) and CIN (lower 4 bits) */
    const uint8_t header = packet4[0];
    const uint8_t cable = header >> 4;
    const uint8_t cin = header & 0x0F;
    
    /* Fast cable validation */
    if (cable > 3) continue;
    
    /* Call debug hook if defined */
    usb_midi_rx_debug_hook(packet4);
    
    /* Map cable 0-3 to USB_PORT0-3 nodes (like MIOS32's USB0-USB3) */
    const uint8_t node = ROUTER_NODE_USB_PORT0 + cable;
    
    /* Handle SysEx messages (CIN 0x4-0x7) - optimized path */
    if (cin >= 0x04 && cin <= 0x07) {
      sysex_buffer_t* const buf = &sysex_buffers[cable];
      const uint8_t num_bytes = cin_to_length[cin];
      
      /* CIN 0x4: SysEx start or continue (3 bytes) */
      if (cin == 0x04) {
        /* If first byte is F0, start new SysEx */
        if (packet4[1] == 0xF0) {
          buf->pos = 0;
          buf->active = 1;
        }
        
        /* Fast buffer copy if active and space available (unrolled for 3 bytes) */
        if (buf->active) {
          if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
            buf->buffer[buf->pos] = packet4[1];
            buf->buffer[buf->pos + 1] = packet4[2];
            buf->buffer[buf->pos + 2] = packet4[3];
            buf->pos += 3;
          } else {
            /* Buffer overflow - discard this SysEx and reset */
            buf->pos = 0;
            buf->active = 0;
          }
        }
        continue; /* Don't process yet - wait for end packet */
    }
    
    /* CIN 0x5: SysEx end with 1 byte (or single-byte System Common) */
    else if (cin == 0x05) {
      if (buf->active) {
        if (buf->pos + 1 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          buf->buffer[buf->pos++] = packet4[1];
          
          /* Fast SysEx validation (check start and end markers) */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MidiCore query message - queue for task processing */
            if (midicore_query_is_query_message(buf->buffer, buf->pos)) {
              // Queue for processing from task context (ISR-safe, no USB TX from ISR!)
              midicore_query_queue(buf->buffer, buf->pos, cable);
              // Don't route query messages - they'll be processed from queue
            } else {
              /* Only route if not in test mode with APP_TEST_USB_MIDI */
              #ifndef APP_TEST_USB_MIDI
              /* Prepare message inline to avoid extra copies */
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      continue;
    }
    
    /* CIN 0x6: SysEx end with 2 bytes (or two-byte System Common) */
    else if (cin == 0x06) {
      if (!buf->active && packet4[1] == 0xF0) {
        buf->pos = 0;
        buf->active = 1;
      }
      if (buf->active) {
        if (buf->pos + 2 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 2 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->pos += 2;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MidiCore query message - queue for task processing */
            if (midicore_query_is_query_message(buf->buffer, buf->pos)) {
              // Queue for processing from task context (ISR-safe, no USB TX from ISR!)
              midicore_query_queue(buf->buffer, buf->pos, cable);
              // Don't route query messages - they'll be processed from queue
            } else {
              #ifndef APP_TEST_USB_MIDI
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      continue;
    }
    
    /* CIN 0x7: SysEx end with 3 bytes */
    else if (cin == 0x07) {
      if (!buf->active && packet4[1] == 0xF0) {
        buf->pos = 0;
        buf->active = 1;
      }
      if (buf->active) {
        if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 3 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->buffer[buf->pos + 2] = packet4[3];
          buf->pos += 3;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MidiCore query message - queue for task processing */
            if (midicore_query_is_query_message(buf->buffer, buf->pos)) {
              // Queue for processing from task context (ISR-safe, no USB TX from ISR!)
              midicore_query_queue(buf->buffer, buf->pos, cable);
              // Don't route query messages - they'll be processed from queue
            } else {
              #ifndef APP_TEST_USB_MIDI
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      continue;
    }
    
    /* Handle regular MIDI messages (non-SysEx) - optimized with lookup table */
    const uint8_t msg_len = cin_to_length[cin];
    
    /* Fast rejection of invalid CINs */
    if (msg_len == 0) continue;
    
    /* Prepare message inline - optimized for common case (3-byte messages) */
    router_msg_t msg;
    msg.data = NULL;
    msg.len = 0;
    msg.b0 = packet4[1];
    msg.b1 = packet4[2];
    msg.b2 = packet4[3];
    
    /* Set message type based on length (fast path) */
    if (msg_len == 3) {
      msg.type = ROUTER_MSG_3B;
    } else if (msg_len == 2) {
      msg.type = ROUTER_MSG_2B;
      msg.b2 = 0;
    } else { /* msg_len == 1 */
      msg.type = ROUTER_MSG_1B;
      msg.b1 = 0;
      msg.b2 = 0;
    }
    
    /* Send to router */
    router_process(node, &msg);
  } /* end while (!rx_queue_is_empty()) */
}

/* Callbacks */
/* TX Complete callback - called from USB MIDI class when packet transmission completes */
void usb_midi_tx_complete(void) {
  /* Send next packet from queue */
  tx_queue_send_next();
}

static void USBD_MIDI_Init_Callback(void) {
  /* USB MIDI initialized - all 4 ports ready */
#if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES  
  extern void dbg_printf(const char *fmt, ...);
  dbg_printf("[USB-MIDI] USB Device MIDI class initialized - ready for queries\r\n");
#endif
}

static void USBD_MIDI_DeInit_Callback(void) {
  /* USB MIDI de-initialized */
#if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES  
  extern void dbg_printf(const char *fmt, ...);
  dbg_printf("[USB-MIDI] USB Device MIDI class de-initialized\r\n");
#endif
}

static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet) {
  /* Forward packet to application layer (4-byte USB MIDI packet) */
  usb_midi_rx_packet((uint8_t*)packet);
  
  /* Note: Individual RX packets are logged by usb_midi_rx_debug_hook() in task context */
}

#else /* !MODULE_ENABLE_USB_MIDI || !USB_DEVICE_AVAILABLE */

/* Stub implementations when USB Device MIDI is not enabled or USB_DEVICE files don't exist */
void usb_midi_init(void) {
  /* USB Device MIDI not available - either disabled or CubeMX files not generated yet */
}

bool usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  (void)cin; (void)b0; (void)b1; (void)b2;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
  return false;  /* Cannot send */
}

void usb_midi_rx_packet(const uint8_t packet4[4]) {
  (void)packet4;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
}

#endif /* MODULE_ENABLE_USB_MIDI && USB_DEVICE_AVAILABLE */

bool usb_midi_get_tx_status(uint32_t *queue_size, uint32_t *queue_used, uint32_t *queue_drops) {
#if MODULE_ENABLE_USB_MIDI
  USBD_MIDI_HandleTypeDef *hmidi = usb_midi_get_class_data();
  
  if (queue_size) *queue_size = USB_MIDI_TX_QUEUE_SIZE;
  if (queue_used) *queue_used = tx_queue_count();
  if (queue_drops) *queue_drops = tx_queue_drops;
  
  return (hmidi != NULL && hmidi->is_ready);
#else
  if (queue_size) *queue_size = 0;
  if (queue_used) *queue_used = 0;
  if (queue_drops) *queue_drops = 0;
  return false;
#endif
}
