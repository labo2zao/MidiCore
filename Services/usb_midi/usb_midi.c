#include "Services/usb_midi/usb_midi.h"
#include "Services/router/router.h"
#include "Services/midicore_query/midicore_query.h"
#include "Config/module_config.h"
#include <string.h>

/* Check if USB Device files are available before including them */


#if MODULE_ENABLE_USB_MIDI

#include "usb_device.h"
#include "USB_DEVICE/Class/MIDI/Inc/usbd_midi.h"  /* Custom MIDI class - protected from CubeMX regen */
#include "USB_DEVICE/App/usbd_composite.h"

/* External USB Device handle (generated by CubeMX) */
extern USBD_HandleTypeDef hUsbDeviceFS;

/* Optional debug hook for test modules - weak symbol can be overridden */
__attribute__((weak)) void usb_midi_rx_debug_hook(const uint8_t packet4[4]) {
  /* Default: do nothing. Test modules can override this to log packets */
  (void)packet4;
}

/* SysEx buffer management - one buffer per cable (4 cables total) */
#define USB_MIDI_SYSEX_BUFFER_SIZE 256
typedef struct {
  uint8_t buffer[USB_MIDI_SYSEX_BUFFER_SIZE];
  uint16_t pos;
  uint8_t active;
  uint8_t padding; // Align to 4-byte boundary for faster access
} sysex_buffer_t;

static sysex_buffer_t sysex_buffers[4] __attribute__((aligned(4))); // 4 cables, 4-byte aligned

/* TX Queue for packet buffering - CRITICAL FIX for packet dropping issue
 * 
 * Problem: usb_midi_send_sysex() calls usb_midi_send_packet() multiple times in a tight loop
 * for multi-packet messages. USB Full Speed can only transmit 1 packet per ~1ms, but we were
 * trying to send packets in microseconds, causing all but the first packet to be dropped.
 * 
 * Solution: Queue packets and send them as TX completes (flow control).
 * 
 * QUEUE SIZE: Increased from 32 to 64 packets to handle debug message bursts.
 * - Each debug SysEx message = ~8-10 packets
 * - 64 packets = ~6-8 complete debug messages can be queued
 * - Prevents drops during high-volume debug output (e.g., MIOS Studio terminal)
 */
#define USB_MIDI_TX_QUEUE_SIZE 64  // Power of 2 for efficient modulo with & mask
typedef struct {
  uint8_t packet[4];  // CIN + 3 data bytes
} tx_packet_t;

static tx_packet_t tx_queue[USB_MIDI_TX_QUEUE_SIZE] __attribute__((aligned(4)));
static volatile uint8_t tx_queue_head = 0;  // Next position to write
static volatile uint8_t tx_queue_tail = 0;  // Next position to read
static volatile uint8_t tx_in_progress = 0; // Flag: transmission active
static volatile uint32_t tx_queue_drops = 0; // Count of dropped packets due to queue full

/* TX Queue helper functions */
static inline uint8_t tx_queue_is_full(void) {
  return ((tx_queue_head + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1)) == tx_queue_tail;
}

static inline uint8_t tx_queue_is_empty(void) {
  return tx_queue_head == tx_queue_tail;
}

static inline uint8_t tx_queue_count(void) {
  if (tx_queue_head >= tx_queue_tail) {
    return tx_queue_head - tx_queue_tail;
  } else {
    return USB_MIDI_TX_QUEUE_SIZE - tx_queue_tail + tx_queue_head;
  }
}

static void tx_queue_send_next(void);

/* RX Queue for deferred processing - CRITICAL FIX for interrupt context issues
 * 
 * Problem: RX interrupt was processing packets immediately, including sending TX responses
 * in the same interrupt context. This violates USB protocol and causes race conditions.
 * 
 * Solution: Queue RX packets in interrupt, process them in task context.
 */
#define USB_MIDI_RX_QUEUE_SIZE 16  // Power of 2
typedef struct {
  uint8_t packet[4];  // Header (cable+CIN) + 3 data bytes
} rx_packet_t;

static rx_packet_t rx_queue[USB_MIDI_RX_QUEUE_SIZE] __attribute__((aligned(4)));
static volatile uint8_t rx_queue_head = 0;  // Next position to write (ISR)
static volatile uint8_t rx_queue_tail = 0;  // Next position to read (task)

/* RX Queue helper functions */
static inline uint8_t rx_queue_is_full(void) {
  return ((rx_queue_head + 1) & (USB_MIDI_RX_QUEUE_SIZE - 1)) == rx_queue_tail;
}

static inline uint8_t rx_queue_is_empty(void) {
  return rx_queue_head == rx_queue_tail;
}

/* Message length lookup table for faster processing (indexed by CIN 0x0-0xF) */
static const uint8_t cin_to_length[16] = {
  0, // 0x0: Reserved
  0, // 0x1: Reserved
  2, // 0x2: Two-byte System Common
  3, // 0x3: Three-byte System Common
  3, // 0x4: SysEx start/continue (3 bytes)
  1, // 0x5: SysEx end 1 byte / Single-byte System Common
  2, // 0x6: SysEx end 2 bytes
  3, // 0x7: SysEx end 3 bytes
  3, // 0x8: Note Off
  3, // 0x9: Note On
  3, // 0xA: Poly Aftertouch
  3, // 0xB: Control Change
  2, // 0xC: Program Change
  2, // 0xD: Channel Pressure
  3, // 0xE: Pitch Bend
  1  // 0xF: Single byte (System Real-Time)
};

/* MIDI Interface Callbacks */
static void USBD_MIDI_Init_Callback(void);
static void USBD_MIDI_DeInit_Callback(void);
static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet);

static USBD_MIDI_ItfTypeDef midi_fops = {
  USBD_MIDI_Init_Callback,
  USBD_MIDI_DeInit_Callback,
  USBD_MIDI_DataOut_Callback
};

static USBD_MIDI_HandleTypeDef *usb_midi_get_class_data(void) {
#if MODULE_ENABLE_USB_CDC
  void *class_data = USBD_COMPOSITE_GetClassData(&USBD_MIDI);
  if (class_data != NULL) {
    return (USBD_MIDI_HandleTypeDef *)class_data;
  }
#endif
  return (USBD_MIDI_HandleTypeDef *)hUsbDeviceFS.pClassData;
}

void usb_midi_init(void) {
  /* Initialize SysEx buffers */
  memset(sysex_buffers, 0, sizeof(sysex_buffers));
  
  /* Initialize TX queue */
  tx_queue_head = 0;
  tx_queue_tail = 0;
  tx_in_progress = 0;
  
  /* Register interface callbacks with USB Device MIDI class */
  USBD_MIDI_RegisterInterface(&hUsbDeviceFS, &midi_fops);
}

/* Send next packet from TX queue (called from tx_queue_send_next and DataIn callback) */
static void tx_queue_send_next(void) {
  USBD_MIDI_HandleTypeDef *hmidi = usb_midi_get_class_data();
  
  /* DEBUG: Add instrumentation to trace TX failures */
  #if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES
  extern void test_debug_tx_trace(uint8_t code);
  #endif
  
  /* DIAGNOSTIC: Track why TX might fail */
  static uint32_t diagnostic_counter = 0;
  diagnostic_counter++;
  
  /* Check if interface is ready */
  if (hmidi == NULL || !hmidi->is_ready) {
    #if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES
    test_debug_tx_trace(0x01); // Class data NULL or not ready
    #endif
    
    /* CRITICAL DIAGNOSTIC: Report NULL class data or not ready */
    if (diagnostic_counter % 1000 == 0) {  // Report every 1000 attempts
      #if MODULE_ENABLE_USB_CDC
      extern void usb_cdc_send(const uint8_t* data, size_t len);
      char diag[100];
      int len = snprintf(diag, sizeof(diag),
                        "[TX-FAIL] hmidi=%p ready=%d attempts=%lu\r\n",
                        (void*)hmidi, hmidi ? hmidi->is_ready : -1,
                        (unsigned long)diagnostic_counter);
      if (len > 0) usb_cdc_send((uint8_t*)diag, len);
      #endif
    }
    
    tx_in_progress = 0;
    return;
  }
  
  /* Check if queue is empty */
  if (tx_queue_is_empty()) {
    #if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES
    test_debug_tx_trace(0x02); // Queue empty
    #endif
    tx_in_progress = 0;
    return;
  }
  
  /* Check if endpoint is busy */
  if (hUsbDeviceFS.ep_in[MIDI_IN_EP & 0x0F].status == USBD_BUSY) {
    #if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES
    test_debug_tx_trace(0x03); // Endpoint busy
    #endif
    /* Endpoint busy - keep tx_in_progress flag set, will retry on next TX complete */
    
    /* DIAGNOSTIC: Report endpoint busy condition */
    if (diagnostic_counter % 5000 == 0) {  // Report every 5000 attempts
      #if MODULE_ENABLE_USB_CDC
      extern void usb_cdc_send(const uint8_t* data, size_t len);
      char diag[80];
      int len = snprintf(diag, sizeof(diag),
                        "[TX-BUSY] Endpoint busy, queue=%d items\r\n",
                        (tx_queue_head >= tx_queue_tail) ? 
                         (tx_queue_head - tx_queue_tail) :
                         (USB_MIDI_TX_QUEUE_SIZE - tx_queue_tail + tx_queue_head));
      if (len > 0) usb_cdc_send((uint8_t*)diag, len);
      #endif
    }
    
    return;
  }
  
  /* Get next packet from queue */
  tx_packet_t *pkt = &tx_queue[tx_queue_tail];
  tx_queue_tail = (tx_queue_tail + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1);
  
  /* Mark transmission in progress */
  tx_in_progress = 1;
  
  /* Transmit packet */
  USBD_LL_Transmit(&hUsbDeviceFS, MIDI_IN_EP, pkt->packet, 4);
}

bool usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  /* CRITICAL FIX: Queue packets instead of sending directly
   * 
   * Problem: Calling USBD_LL_Transmit() in a tight loop causes packet drops because
   * USB Full Speed can only handle ~1 packet per ms, but we were sending packets in Î¼s.
   * 
   * Solution: Buffer packets in queue, send as TX completes (flow control).
   * This ensures reliable multi-packet message delivery (SysEx, etc.)
   * 
   * Returns true if packet queued, false if queue full (caller can implement backpressure)
   */
  
  /* DEBUG: Trace packet arrival */
  #if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES
  extern void test_debug_tx_packet_queued(uint8_t cin, uint8_t b0);
  test_debug_tx_packet_queued(cin, b0);
  #endif
  
  /* Check if queue is full */
  if (tx_queue_is_full()) {
    #if defined(MODULE_TEST_USB_DEVICE_MIDI) || MODULE_DEBUG_MIDICORE_QUERIES
    extern void test_debug_tx_trace(uint8_t code);
    test_debug_tx_trace(0xFF); // Queue full!
    #endif
    /* Queue full - return false so caller knows packet was dropped */
    tx_queue_drops++;  // Track drops
    return false;
  }
  
  /* Add packet to queue */
  tx_packet_t *pkt = &tx_queue[tx_queue_head];
  pkt->packet[0] = cin;  /* Cable number (upper 4 bits) + CIN (lower 4 bits) */
  pkt->packet[1] = b0;
  pkt->packet[2] = b1;
  pkt->packet[3] = b2;
  tx_queue_head = (tx_queue_head + 1) & (USB_MIDI_TX_QUEUE_SIZE - 1);
  
  /* If no transmission in progress, start sending */
  if (!tx_in_progress) {
    tx_queue_send_next();
  }
  
  return true;  /* Packet queued successfully */
}

/* CRITICAL FIX: Queue RX packet for deferred processing
 * 
 * This function is called from USB interrupt context. We MUST NOT do heavy processing
 * here (router, MidiCore queries, TX operations). Instead, queue the packet and return
 * immediately. Processing happens in task context via usb_midi_process_rx_queue().
 * 
 * This fixes the freeze issue where MidiCore query responses were being sent from
 * RX interrupt, violating USB protocol and causing race conditions.
 */
void usb_midi_rx_packet(const uint8_t packet4[4]) {
  /* INTERRUPT CONTEXT - Keep this FAST! */
  
  /* Check if queue is full (should be rare with 16-deep queue) */
  if (rx_queue_is_full()) {
    /* Drop packet - queue overflow */
    return;
  }
  
  /* Copy packet to queue (4-byte copy is atomic on 32-bit CPU) */
  rx_packet_t *pkt = &rx_queue[rx_queue_head];
  pkt->packet[0] = packet4[0];
  pkt->packet[1] = packet4[1];
  pkt->packet[2] = packet4[2];
  pkt->packet[3] = packet4[3];
  
  /* Advance write pointer */
  rx_queue_head = (rx_queue_head + 1) & (USB_MIDI_RX_QUEUE_SIZE - 1);
  
  /* That's it! Processing happens in task context */
}

/* Process RX queue - MUST be called from task context (NOT interrupt!)
 * 
 * Call this from main loop or dedicated USB MIDI task. It processes all queued
 * RX packets, assembles SysEx messages, handles MidiCore queries, and routes to
 * the MIDI router.
 * 
 * This function contains the actual processing logic that was previously in
 * usb_midi_rx_packet() but is now properly deferred to task context.
 */
void usb_midi_process_rx_queue(void) {
  /* TASK CONTEXT - Safe to do heavy processing and TX operations */
  
  /* Process all queued packets */
  while (!rx_queue_is_empty()) {
    /* Get next packet from queue */
    rx_packet_t *pkt = &rx_queue[rx_queue_tail];
    const uint8_t *packet4 = pkt->packet;
    
    /* Advance read pointer before processing (in case processing triggers more RX) */
    rx_queue_tail = (rx_queue_tail + 1) & (USB_MIDI_RX_QUEUE_SIZE - 1);
    
    /* NOW do the actual processing (same logic as before, but in task context) */
    
    /* Extract cable number (upper 4 bits) and CIN (lower 4 bits) */
    const uint8_t header = packet4[0];
    const uint8_t cable = header >> 4;
    const uint8_t cin = header & 0x0F;
    
    /* Fast cable validation */
    if (cable > 3) continue;
    
    /* Call debug hook if defined */
    usb_midi_rx_debug_hook(packet4);
    
    /* Map cable 0-3 to USB_PORT0-3 nodes (like MIOS32's USB0-USB3) */
    const uint8_t node = ROUTER_NODE_USB_PORT0 + cable;
    
    /* Handle SysEx messages (CIN 0x4-0x7) - optimized path */
    if (cin >= 0x04 && cin <= 0x07) {
      sysex_buffer_t* const buf = &sysex_buffers[cable];
      const uint8_t num_bytes = cin_to_length[cin];
      
      /* CIN 0x4: SysEx start or continue (3 bytes) */
      if (cin == 0x04) {
        /* If first byte is F0, start new SysEx */
        if (packet4[1] == 0xF0) {
          buf->pos = 0;
          buf->active = 1;
        }
        
        /* Fast buffer copy if active and space available (unrolled for 3 bytes) */
        if (buf->active) {
          if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
            buf->buffer[buf->pos] = packet4[1];
            buf->buffer[buf->pos + 1] = packet4[2];
            buf->buffer[buf->pos + 2] = packet4[3];
            buf->pos += 3;
          } else {
            /* Buffer overflow - discard this SysEx and reset */
            buf->pos = 0;
            buf->active = 0;
          }
        }
        continue; /* Don't process yet - wait for end packet */
    }
    
    /* CIN 0x5: SysEx end with 1 byte (or single-byte System Common) */
    else if (cin == 0x05) {
      if (buf->active) {
        if (buf->pos + 1 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          buf->buffer[buf->pos++] = packet4[1];
          
          /* Fast SysEx validation (check start and end markers) */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MidiCore query message - queue for task processing */
            if (midicore_query_is_query_message(buf->buffer, buf->pos)) {
              // Queue for processing from task context (ISR-safe, no USB TX from ISR!)
              midicore_query_queue(buf->buffer, buf->pos, cable);
              // Don't route query messages - they'll be processed from queue
            } else {
              /* Only route if not in test mode with APP_TEST_USB_MIDI */
              #ifndef APP_TEST_USB_MIDI
              /* Prepare message inline to avoid extra copies */
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      continue;
    }
    
    /* CIN 0x6: SysEx end with 2 bytes (or two-byte System Common) */
    else if (cin == 0x06) {
      if (!buf->active && packet4[1] == 0xF0) {
        buf->pos = 0;
        buf->active = 1;
      }
      if (buf->active) {
        if (buf->pos + 2 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 2 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->pos += 2;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MidiCore query message - queue for task processing */
            if (midicore_query_is_query_message(buf->buffer, buf->pos)) {
              // Queue for processing from task context (ISR-safe, no USB TX from ISR!)
              midicore_query_queue(buf->buffer, buf->pos, cable);
              // Don't route query messages - they'll be processed from queue
            } else {
              #ifndef APP_TEST_USB_MIDI
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      continue;
    }
    
    /* CIN 0x7: SysEx end with 3 bytes */
    else if (cin == 0x07) {
      if (!buf->active && packet4[1] == 0xF0) {
        buf->pos = 0;
        buf->active = 1;
      }
      if (buf->active) {
        if (buf->pos + 3 <= USB_MIDI_SYSEX_BUFFER_SIZE) {
          /* Unrolled copy for 3 bytes */
          buf->buffer[buf->pos] = packet4[1];
          buf->buffer[buf->pos + 1] = packet4[2];
          buf->buffer[buf->pos + 2] = packet4[3];
          buf->pos += 3;
          
          /* Fast SysEx validation */
          if (buf->pos >= 2 && buf->buffer[0] == 0xF0 && buf->buffer[buf->pos-1] == 0xF7) {
            /* Check if this is a MidiCore query message - queue for task processing */
            if (midicore_query_is_query_message(buf->buffer, buf->pos)) {
              // Queue for processing from task context (ISR-safe, no USB TX from ISR!)
              midicore_query_queue(buf->buffer, buf->pos, cable);
              // Don't route query messages - they'll be processed from queue
            } else {
              #ifndef APP_TEST_USB_MIDI
              router_msg_t msg;
              msg.type = ROUTER_MSG_SYSEX;
              msg.data = buf->buffer;
              msg.len = buf->pos;
              msg.b0 = 0xF0;
              msg.b1 = 0;
              msg.b2 = 0;
              router_process(node, &msg);
              #endif
            }
          }
        }
        /* Always reset buffer state after end packet (even on overflow) */
        buf->pos = 0;
        buf->active = 0;
      }
      continue;
    }
  }
  
  /* Handle regular MIDI messages (non-SysEx) - optimized with lookup table */
  const uint8_t msg_len = cin_to_length[cin];
  
  /* Fast rejection of invalid CINs */
  if (msg_len == 0) continue;
  
  /* Prepare message inline - optimized for common case (3-byte messages) */
  router_msg_t msg;
  msg.data = NULL;
  msg.len = 0;
  msg.b0 = packet4[1];
  msg.b1 = packet4[2];
  msg.b2 = packet4[3];
  
  /* Set message type based on length (fast path) */
  if (msg_len == 3) {
    msg.type = ROUTER_MSG_3B;
  } else if (msg_len == 2) {
    msg.type = ROUTER_MSG_2B;
    msg.b2 = 0;
    } else { /* msg_len == 1 */
      msg.type = ROUTER_MSG_1B;
      msg.b1 = 0;
      msg.b2 = 0;
    }
    
    /* Send to router */
    router_process(node, &msg);
  } /* end while (!rx_queue_is_empty()) */
}

/* Callbacks */
/* TX Complete callback - called from USB MIDI class when packet transmission completes */
void usb_midi_tx_complete(void) {
  /* Send next packet from queue */
  tx_queue_send_next();
}

static void USBD_MIDI_Init_Callback(void) {
  /* USB MIDI initialized - all 4 ports ready */
}

static void USBD_MIDI_DeInit_Callback(void) {
  /* USB MIDI de-initialized */
}

static void USBD_MIDI_DataOut_Callback(USBD_MIDI_EventPacket_t *packet) {
  /* Forward packet to application layer (4-byte USB MIDI packet) */
  usb_midi_rx_packet((uint8_t*)packet);
}

#else /* !MODULE_ENABLE_USB_MIDI || !USB_DEVICE_AVAILABLE */

/* Stub implementations when USB Device MIDI is not enabled or USB_DEVICE files don't exist */
void usb_midi_init(void) {
  /* USB Device MIDI not available - either disabled or CubeMX files not generated yet */
}

bool usb_midi_send_packet(uint8_t cin, uint8_t b0, uint8_t b1, uint8_t b2) {
  (void)cin; (void)b0; (void)b1; (void)b2;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
  return false;  /* Cannot send */
}

void usb_midi_rx_packet(const uint8_t packet4[4]) {
  (void)packet4;
  /* Stub: USB Device MIDI not enabled or CubeMX files not generated */
}

#endif /* MODULE_ENABLE_USB_MIDI && USB_DEVICE_AVAILABLE */

bool usb_midi_get_tx_status(uint32_t *queue_size, uint32_t *queue_used, uint32_t *queue_drops) {
#if MODULE_ENABLE_USB_MIDI
  USBD_MIDI_HandleTypeDef *hmidi = usb_midi_get_class_data();
  
  if (queue_size) *queue_size = USB_MIDI_TX_QUEUE_SIZE;
  if (queue_used) *queue_used = tx_queue_count();
  if (queue_drops) *queue_drops = tx_queue_drops;
  
  return (hmidi != NULL && hmidi->is_ready);
#else
  if (queue_size) *queue_size = 0;
  if (queue_used) *queue_used = 0;
  if (queue_drops) *queue_drops = 0;
  return false;
#endif
}
